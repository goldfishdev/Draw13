#include <conio.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <alloc.h>
#include "d13lib.h"

unsigned char far buffer[320L*200]; // create buffer
volatile char keyStates[128];

Sprite sprites[MAX_SPRITES];
int numLoadedSprites = 0;

// sets mode to 13h. might work for other modes. idk
void set_vga_mode()
{
	union REGS regs;
	regs.h.ah = 0x00;
	regs.h.al = 0x13;
	int86(0x10, &regs, &regs);

}

// sets mode back to text
void set_text_mode()
{
    union REGS regs;
    regs.h.ah = 0x00;
    regs.h.al = 0x03;  // 80x25 text mode
    int86(0x10, &regs, &regs);
}

// sets to all black. will add colors at some point
void clear_buffer()
{
	_fmemset(buffer, 0, 320*200);
}

// sets vga to the buffer all at once
void copy_buffer()
{
	unsigned char far *vga = (unsigned char far*)0xA0000000L;
	_fmemcpy(vga, buffer, 320*200);
}

// puts a pixel in the buffer at a position
void put_pixel(int x, int y, unsigned char color)
{
	if (x >= 0 && x < 320 && y >= 0 && y < 200) {
		buffer[y * 320 + x] = color; // set pixel in buffer
	}
}

// i could theoretically use this function to draw other shapes
// but idk if it would be faster
void draw_polygon(struct Vector2 vertices[], int num_vertices, unsigned char color)
{
	int i;
	if (num_vertices < 2) return;
	for (i = 0; i < num_vertices - 1; i++) {
		draw_line(vertices[i].x, vertices[i].y,
				  vertices[i+1].x, vertices[i+1].y, color);
	}
	draw_line(vertices[num_vertices-1].x, vertices[num_vertices-1].y,
			  vertices[0].x, vertices[0].y, color);
}

// integer square root
int isqrt(int num)
{
	int res = 0;
	int bit = 1 << 14;
	while (bit < num) {
		bit >>= 2;
	}
	while (bit != 0) {
		if (num >= res + bit) {
			num -= res + bit;
			res = (res >> 1) + bit;
		} else {
			res >>= 1;
		}
		bit >>= 2;
	}
	return res;
}

// draw rectangle with set corners
void draw_rect(int x1, int y1, int x2, int y2, bool filled, unsigned char color)
{
	int width = x2 - x1;
	int scaled_width = (width*4)/3;
	int x, y;
	if (filled == true) {
		for (y = y1; y <= y2; y++) {
			for (x = x1; x <= x1 + scaled_width; x++) {
				put_pixel(x, y, color);
			}
		}
	}
	else {
		for (x = x1; x <= x1 + scaled_width; x++) {
			put_pixel(x, y1, color);
			put_pixel(x, y2, color);
		}
		for (y = y1; y <= y2; y++) {
			put_pixel(x1, y, color);
			put_pixel(x1 + scaled_width, y, color);
		}
	}
}

// draws rectangle using Rectangle. WIP
void draw_rectangle(Rectangle rect, bool filled, unsigned char color)
{
	int scaled_width = (rect.width*4)/3;
	int x1 = rect.x;
	int y1 = rect.y;
	int x2 = x1 + scaled_width;
	int y2 = y1 + rect.height;
	int xc, yc;
	if (filled == true) {
		for (yc = y1; yc <= y2; yc++) {
			for (xc = x1; xc <= x2; xc++) {
				put_pixel(xc, yc, color);
			}
		}
	}
	else {
		for (xc = x1; xc <= x2; xc++) {
			put_pixel(xc, y1, color);
			put_pixel(xc, y2, color);
		}
		for (yc = y1; yc <= y2; yc++) {
			put_pixel(x1, yc, color);
			put_pixel(x2, yc, color);
		}
	}
}

// draws a line
void draw_line(int x1, int y1, int x2, int y2, unsigned char color)
{
	int dx, dy, sx, sy, err, e2;
	dx = abs(x2 - x1);
	dy = abs(y2 - y1);
	sx = (x1 < x2) ? 1 : -1;
	sy = (y1 < y2) ? 1 : -1;
	err = dx - dy;
	while (1) {
		put_pixel(x1, y1, color);
		if (x1 == x2 && y1 == y2) break;
		e2 = 2 * err;
		if (e2 > -dy) {
			err -= dy;
			x1 += sx;
		}
		if (e2 < dx) {
			err += dx;
			y1 += sy;
		}
	}
}

// weird scaling but it's a bit better than what I had before.
// no option for not filled yet
void draw_ellipse(int cx, int cy, int width, int height, unsigned char color)
{
	int rx = width / 2;
	int ry = height / 2;
	int ry2 = ry * ry;
	int x, y, dx, start, end, py;
	float ratio, p;
	for (y = -ry; y < ry; y++) {
		x = (rx * isqrt(ry2 - y * y)) / ry;

		for (dx = -x; dx < x; dx++) {
			put_pixel(cx + dx, cy + y, color);
		}
	}
}

// not perfect. has some weird bits sticking out. good enough ig
void draw_circle(int cx, int cy, int radius, unsigned char color)
{
	int scaled = (radius * 4 / 3);
	draw_ellipse(cx, cy, scaled, radius, color);
}

// draw single character
void draw_char(unsigned char ascii, int x, int y, unsigned char color)
{
	unsigned char byte;
	unsigned char bit;
	int font_offset;
	int row, col;
	font_offset = ascii * BYTES_PER_CHAR;
	for (row = 0; row < CHAR_HEIGHT; row++) {
		byte = DefaultFont[font_offset + row];
		for (col = 0; col < CHAR_WIDTH; col++) {
			bit = (byte >> (7 - col)) & 0x01;
			if (bit) {
				put_pixel(x + col, y + row, color);
			}
		}
	}
}

// draw text. used draw_char
void draw_string(const char* txt, int x, int y, unsigned char color)
{
	int i = 0;
	int current_x = x;
	while (txt[i] != '\0') {
		if (current_x + CHAR_WIDTH >= 320) break;
		draw_char(txt[i], current_x, y, color);
		current_x += KERNING;
		i++;
	}
}

// input

void interrupt (*oldKeyboardHandler)();

void interrupt keyboardHandler()
{
	static unsigned char scanCode;
	scanCode = inportb(0x60);
	if (scanCode & 0x80) {
		scanCode &= 0x7F;
		keyStates[scanCode] = 0;
	} else {
		keyStates[scanCode] = 1;
	}
	outportb(0x20, 0x20);
	oldKeyboardHandler();
}

void initKeyboard()
{
	oldKeyboardHandler = getvect(9);
	setvect(9, keyboardHandler);
}

void deinitKeyboard()
{
	setvect(9, oldKeyboardHandler);
}
int isKeyDown(int scanCode) {
	return keyStates[scanCode];
}


/* adapted from Adam Ward's 13h font
 * I'll add a fonts page in the docs for more info at some point
 * not all characters exist, many are blank
 * I'm sure there's a better way to do this
 * sorry in advance
*/
const unsigned char DefaultFont[256 * BYTES_PER_CHAR] = {
	/* ASCII   0 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   1 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   2 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   3 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   4 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   5 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   6 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   7 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   8 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII   9 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  10 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  11 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  12 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  13 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  14 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  15 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  16 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  17 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  18 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  19 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  20 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  21 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  22 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  23 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  24 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  25 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  26 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  27 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  28 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  29 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  30 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  31 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  32 ' ' */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  33 '!' */
	0x20, 0x20, 0x20, 0x20, 0x00, 0x20,
	/* ASCII  34 '"' */
	0x50, 0x50, 0x00, 0x00, 0x00, 0x00,
	/* ASCII  35 '#' */
	0x00, 0x50, 0xF8, 0x50, 0xF8, 0x50,
	/* ASCII  36 '$' */
	0x20, 0x70, 0xA0, 0x70, 0x28, 0x70,
	/* ASCII  37 '%' */
	0xC8, 0xD0, 0x20, 0x20, 0x58, 0x98,
	/* ASCII  38 '&' */
	0x70, 0x50, 0x60, 0xB0, 0x98, 0x68,
	/* ASCII  39 ''' */
	0x20, 0x20, 0x40, 0x00, 0x00, 0x00,
	/* ASCII  40 '(' */
	0x10, 0x20, 0x20, 0x20, 0x20, 0x10,
	/* ASCII  41 ')' */
	0x40, 0x20, 0x20, 0x20, 0x20, 0x40,
	/* ASCII  42 '*' */
	0x20, 0xF8, 0x20, 0x50, 0x50, 0x00,
	/* ASCII  43 '+' */
	0x00, 0x20, 0x20, 0xF8, 0x20, 0x20,
	/* ASCII  44 ',' */
	0x00, 0x00, 0x00, 0x20, 0x20, 0x40,
	/* ASCII  45 '-' */
	0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
	/* ASCII  46 '.' */
	0x00, 0x00, 0x00, 0x00, 0x60, 0x60,
	/* ASCII  47 '/' */
	0x00, 0x10, 0x10, 0x20, 0x40, 0x40,
	/* ASCII  48 '0' */
	0x70, 0x98, 0xA8, 0xA8, 0xC8, 0x70,
	/* ASCII  49 '1' */
	0x20, 0x60, 0x20, 0x20, 0x20, 0x70,
	/* ASCII  50 '2' */
	0x70, 0x88, 0x10, 0x20, 0x40, 0xF8,
	/* ASCII  51 '3' */
	0x70, 0x88, 0x30, 0x08, 0x88, 0x70,
	/* ASCII  52 '4' */
	0x10, 0x30, 0x50, 0xF8, 0x10, 0x10,
	/* ASCII  53 '5' */
	0xF8, 0x80, 0xF0, 0x08, 0x88, 0x70,
	/* ASCII  54 '6' */
	0x70, 0x80, 0xF0, 0x88, 0x88, 0x70,
	/* ASCII  55 '7' */
	0xF8, 0x08, 0x10, 0x20, 0x20, 0x20,
	/* ASCII  56 '8' */
	0x70, 0x88, 0x70, 0x88, 0x88, 0x70,
	/* ASCII  57 '9' */
	0x70, 0x88, 0x88, 0x78, 0x08, 0x70,
	/* ASCII  58 ':' */
	0x00, 0x00, 0x20, 0x00, 0x20, 0x00,
	/* ASCII  59 ';' */
	0x00, 0x00, 0x20, 0x00, 0x20, 0x40,
	/* ASCII  60 '<' */
	0x00, 0x10, 0x20, 0x40, 0x20, 0x10,
	/* ASCII  61 '=' */
	0x00, 0x00, 0x70, 0x00, 0x70, 0x00,
	/* ASCII  62 '>' */
	0x00, 0x40, 0x20, 0x10, 0x20, 0x40,
	/* ASCII  63 '?' */
	0x70, 0x88, 0x30, 0x20, 0x00, 0x20,
	/* ASCII  64 '@' */
	0x70, 0x88, 0xB8, 0xB0, 0x80, 0x70,
	/* ASCII  65 'A' */
	0x70, 0x88, 0x88, 0xF8, 0x88, 0x88,
	/* ASCII  66 'B' */
	0xF0, 0x88, 0xF0, 0x88, 0x88, 0xF0,
	/* ASCII  67 'C' */
	0x70, 0x88, 0x80, 0x80, 0x88, 0x70,
	/* ASCII  68 'D' */
	0xE0, 0x90, 0x88, 0x88, 0x90, 0xE0,
	/* ASCII  69 'E' */
	0xF8, 0x80, 0xF0, 0x80, 0x80, 0xF8,
	/* ASCII  70 'F' */
	0xF8, 0x80, 0xF0, 0x80, 0x80, 0x80,
	/* ASCII  71 'G' */
	0x70, 0x88, 0x80, 0xB8, 0x88, 0x70,
	/* ASCII  72 'H' */
	0x88, 0x88, 0xF8, 0x88, 0x88, 0x88,
	/* ASCII  73 'I' */
	0xF8, 0x20, 0x20, 0x20, 0x20, 0xF8,
	/* ASCII  74 'J' */
	0xF8, 0x10, 0x10, 0x10, 0x90, 0x60,
	/* ASCII  75 'K' */
	0x88, 0x90, 0xE0, 0x90, 0x88, 0x88,
	/* ASCII  76 'L' */
	0x80, 0x80, 0x80, 0x80, 0x80, 0xF8,
	/* ASCII  77 'M' */
	0xD8, 0xA8, 0xA8, 0xA8, 0x88, 0x88,
	/* ASCII  78 'N' */
	0xC8, 0xC8, 0xA8, 0xA8, 0x98, 0x98,
	/* ASCII  79 'O' */
	0x70, 0x88, 0x88, 0x88, 0x88, 0x70,
	/* ASCII  80 'P' */
	0xF0, 0x88, 0x88, 0xF0, 0x80, 0x80,
	/* ASCII  81 'Q' */
	0x70, 0x88, 0x88, 0xA8, 0x98, 0x78,
	/* ASCII  82 'R' */
	0xF0, 0x88, 0x88, 0xF0, 0xA0, 0x98,
	/* ASCII  83 'S' */
	0x70, 0x88, 0x60, 0x10, 0x88, 0x70,
	/* ASCII  84 'T' */
	0xF8, 0x20, 0x20, 0x20, 0x20, 0x20,
	/* ASCII  85 'U' */
	0x88, 0x88, 0x88, 0x88, 0x88, 0x70,
	/* ASCII  86 'V' */
	0x88, 0x88, 0x88, 0x50, 0x50, 0x20,
	/* ASCII  87 'W' */
	0x88, 0x88, 0xA8, 0xA8, 0xA8, 0x50,
	/* ASCII  88 'X' */
	0x88, 0x50, 0x20, 0x20, 0x50, 0x88,
	/* ASCII  89 'Y' */
	0x88, 0x50, 0x50, 0x20, 0x20, 0x20,
	/* ASCII  90 'Z' */
	0xF8, 0x10, 0x20, 0x40, 0x80, 0xF8,
	/* ASCII  91 '[' */
	0x30, 0x20, 0x20, 0x20, 0x20, 0x30,
	/* ASCII  92 '\' */
	0x00, 0x40, 0x40, 0x20, 0x10, 0x10,
	/* ASCII  93 ']' */
	0x60, 0x20, 0x20, 0x20, 0x20, 0x60,
	/* ASCII  94 '^' */
	0x20, 0x50, 0x88, 0x00, 0x00, 0x00,
	/* ASCII  95 '_' */
	0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
	/* ASCII  96 '`' */
	0x20, 0x20, 0x10, 0x00, 0x00, 0x00,
	/* ASCII  97 'a' */
	0x00, 0x30, 0x48, 0x38, 0x58, 0x68,
	/* ASCII  98 'b' */
	0x40, 0x40, 0x70, 0x48, 0x48, 0x70,
	/* ASCII  99 'c' */
	0x00, 0x00, 0x30, 0x40, 0x40, 0x30,
	/* ASCII 100 'd' */
	0x08, 0x08, 0x38, 0x48, 0x48, 0x38,
	/* ASCII 101 'e' */
	0x00, 0x30, 0x48, 0x78, 0x40, 0x38,
	/* ASCII 102 'f' */
	0x00, 0x18, 0x20, 0x70, 0x20, 0x20,
	/* ASCII 103 'g' */
	0x00, 0x38, 0x48, 0x38, 0x08, 0x30,
	/* ASCII 104 'h' */
	0x40, 0x40, 0x70, 0x48, 0x48, 0x48,
	/* ASCII 105 'i' */
	0x20, 0x00, 0x20, 0x20, 0x20, 0x20,
	/* ASCII 106 'j' */
	0x10, 0x00, 0x10, 0x10, 0x50, 0x20,
	/* ASCII 107 'k' */
	0x40, 0x40, 0x50, 0x60, 0x50, 0x48,
	/* ASCII 108 'l' */
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	/* ASCII 109 'm' */
	0x00, 0x00, 0xF0, 0xA8, 0xA8, 0xA8,
	/* ASCII 110 'n' */
	0x00, 0x00, 0x60, 0x50, 0x50, 0x50,
	/* ASCII 111 'o' */
	0x00, 0x30, 0x48, 0x48, 0x48, 0x30,
	/* ASCII 112 'p' */
	0x00, 0x20, 0x50, 0x60, 0x40, 0x40,
	/* ASCII 113 'q' */
	0x00, 0x30, 0x50, 0x30, 0x18, 0x10,
	/* ASCII 114 'r' */
	0x00, 0x00, 0x58, 0x60, 0x40, 0x40,
	/* ASCII 115 's' */
	0x00, 0x30, 0x40, 0x20, 0x10, 0x60,
	/* ASCII 116 't' */
	0x00, 0x20, 0x70, 0x20, 0x28, 0x10,
	/* ASCII 117 'u' */
	0x00, 0x00, 0x50, 0x50, 0x50, 0x30,
	/* ASCII 118 'v' */
	0x00, 0x00, 0x50, 0x50, 0x20, 0x20,
	/* ASCII 119 'w' */
	0x00, 0x00, 0x88, 0xA8, 0xA8, 0x50,
	/* ASCII 120 'x' */
	0x00, 0x00, 0x50, 0x20, 0x50, 0x50,
	/* ASCII 121 'y' */
	0x00, 0x00, 0x50, 0x70, 0x10, 0x60,
	/* ASCII 122 'z' */
	0x00, 0x00, 0x70, 0x20, 0x40, 0x70,
	/* ASCII 123 '{' */
	0x10, 0x20, 0x60, 0x20, 0x20, 0x10,
	/* ASCII 124 '|' */
	0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
	/* ASCII 125 '}' */
	0x40, 0x20, 0x30, 0x20, 0x20, 0x40,
	/* ASCII 126 '~' */
	0x00, 0x40, 0xA8, 0x10, 0x00, 0x00,
	/* ASCII 127 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 128 */
	0x20, 0x00, 0x20, 0x20, 0x20, 0x00,
	/* ASCII 129 */
	0x08, 0x38, 0x50, 0x60, 0x38, 0x40,
	/* ASCII 130 */
	0x30, 0x48, 0x40, 0xF0, 0x40, 0xF8,
	/* ASCII 131 */
	0x00, 0x88, 0x70, 0x50, 0x70, 0x88,
	/* ASCII 132 */
	0x88, 0x50, 0xF8, 0x20, 0xF8, 0x20,
	/* ASCII 133 */
	0x20, 0x20, 0x00, 0x20, 0x20, 0x20,
	/* ASCII 134 */
	0x20, 0x50, 0x20, 0x50, 0x20, 0x50,
	/* ASCII 135 */
	0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 136 */
	0x70, 0xB8, 0xC8, 0xC8, 0xB8, 0x70,
	/* ASCII 137 */
	0x30, 0x50, 0x70, 0x00, 0x00, 0x00,
	/* ASCII 138 */
	0x00, 0x28, 0x50, 0xA0, 0x50, 0x28,
	/* ASCII 139 */
	0x00, 0xF8, 0x08, 0x00, 0x00, 0x00,
	/* ASCII 140 */
	0x00, 0x00, 0x00, 0x70, 0x00, 0x00,
	/* ASCII 141 */
	0x70, 0x88, 0xF8, 0xC8, 0xC8, 0x70,
	/* ASCII 142 */
	0xF8, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 143 */
	0x20, 0x50, 0x20, 0x00, 0x00, 0x00,
	/* ASCII 144 */
	0x20, 0x20, 0xF8, 0x20, 0x20, 0xF8,
	/* ASCII 145 */
	0x70, 0x10, 0x20, 0x70, 0x00, 0x00,
	/* ASCII 146 */
	0x70, 0x30, 0x30, 0x70, 0x00, 0x00,
	/* ASCII 147 */
	0x10, 0x20, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 148 */
	0x00, 0x00, 0x50, 0x50, 0x70, 0x40,
	/* ASCII 149 */
	0x38, 0x58, 0x58, 0x38, 0x18, 0x18,
	/* ASCII 150 */
	0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 151 */
	0x00, 0x00, 0x00, 0x20, 0x10, 0x70,
	/* ASCII 152 */
	0x60, 0x20, 0x20, 0x70, 0x00, 0x00,
	/* ASCII 153 */
	0x20, 0x50, 0x50, 0x20, 0x00, 0x00,
	/* ASCII 154 */
	0x00, 0xA0, 0x50, 0x28, 0x50, 0xA0,
	/* ASCII 155 */
	0x88, 0x90, 0xA8, 0x58, 0xB8, 0x08,
	/* ASCII 156 */
	0x88, 0x90, 0xB8, 0x48, 0x90, 0x38,
	/* ASCII 157 */
	0xE8, 0x70, 0xA8, 0x58, 0xB8, 0x08,
	/* ASCII 158 */
	0x20, 0x00, 0x20, 0x60, 0x88, 0x70,
	/* ASCII 159 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 160 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 161 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 162 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 163 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 164 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 165 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 166 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 167 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 168 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 169 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 170 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 171 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 172 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 173 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 174 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 175 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 176 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 177 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 178 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 179 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 180 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 181 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 182 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 183 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 184 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 185 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 186 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 187 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 188 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 189 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 190 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 191 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 192 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 193 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 194 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 195 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 196 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 197 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 198 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 199 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 200 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 201 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 202 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 203 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 204 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 205 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 206 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 207 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 208 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 209 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 210 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 211 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 212 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 213 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 214 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 215 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 216 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 217 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 218 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 219 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 220 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 221 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 222 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 223 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 224 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 225 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 226 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 227 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 228 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 229 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 230 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 231 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 232 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 233 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 234 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 235 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 236 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 237 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 238 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 239 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 240 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 241 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 242 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 243 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 244 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 245 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 246 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 247 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 248 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 249 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 250 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 251 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 252 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 253 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 254 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	/* ASCII 255 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

typedef struct {
	unsigned char r, g, b;
} RGB;

void vga_to_rgb(RGB palette[256])
{
	int i;
	for (i = 0; i < 256; i++) {
		outp(0x3C7, i);                   /* read palette entry */
		palette[i].r = inp(0x3C9) * 4;    /* these scale rgb to roughly 0-252 */
		palette[i].g = inp(0x3C9) * 4;
		palette[i].b = inp(0x3C9) * 4;
	}
}

void rgb_to_vga(RGB palette[256])
{
	int i;
	for (i = 0; i < 256; i++) {
		outp(0x3C8, i);                   /* basically the reverse of vga_to_rgb() */
		outp(0x3C9, palette[i].r * 63 / 255);
		outp(0x3C9, palette[i].g * 63 / 255);
		outp(0x3C9, palette[i].b * 63 / 255);
	}
}

int find_closest_color(RGB color, RGB palette[256])
{
	int i, best_index;
	unsigned long best_d, d;
	long dr, dg, db;

	static int cache[1<<12]; /* 12-bit cache */
	static char inited = 0;

	/* key takes the high 4 bits of each channel */
	int key = ((color.r >> 4) << 8) | ((color.g >> 4) << 4) |  (color.b >> 4);

	/* initialize cache */
	if (!inited) {
		for (i = 0; i < (1<<12); i++) cache[i] = -1;
		inited = 1;
	}

	/* check cache */
	if (cache[key] >= 0) {
		return cache[key];
	}

	/* if not cached, go through all of palette */
	best_index   = 0;
	best_d = 0xFFFFFFFFUL;

	for (i = 0; i < 256; i++) {
		dr = color.r - palette[i].r;
		dg = color.g - palette[i].g;
		db = color.b - palette[i].b;
		d = dr*dr + dg*dg + db*db; /* squared rgb euclidean distance */
		if (d < best_d) {
			best_d = d;
			best_index = i;
		}
	}

	/* cache so we don't keep doing the loop */
	cache[key] = best_index;
	return best_index;
}


int load_sprite(const char *filename) {
	FILE *fp;
	char magic[3];
	int width, height, maxval;
	int r, g, b;
	int i, count;
	int c;
	unsigned char *data;
	int sprite_id = -1;
	RGB palette[256];
	static int palette_initialized = 0;

	if (!palette_initialized) {
		vga_to_rgb(palette);
		palette_initialized = 1;
	}

	/* I have a MAX_SPRITES constant right now that's primarily for dev stuff.
	 * I'll either remove it or add a user-set variable for it */
	for (i = 0; i < MAX_SPRITES; i++) {
		if (!sprites[i].loaded) {
			sprite_id = i;
			break;
		}
	}

	if (sprite_id == -1) {
		printf("Error: No more sprite slots available\n");
		return -1;
	}

	/* these printf errors probably wouldn't show in the programs cuz dos and shit. whatever */
	fp = fopen(filename, "r");
	if (!fp) {
		printf("Error: Cannot open PPM file %s\n", filename);
		return -1;
	}

	// Read PPM header
	if (fscanf(fp, "%2s", magic) != 1) {
		printf("Error: Invalid PPM format\n");
		fclose(fp);
		return -1;
	}

	if (strcmp(magic, "P3") != 0) {
		printf("Error: Not a P3 PPM\n");
		fclose(fp);
		return -1;
	}

	/* skip comments */
	c = getc(fp);
	while (c == '#' || isspace(c)) {
		if (c == '#') {
			while (c != '\n' && c != EOF) {
				c = getc(fp);
			}
		}
		if (c != EOF) {
			c = getc(fp);
		}
	}
	ungetc(c, fp);

	if (fscanf(fp, "%d %d", &width, &height) != 2) {
		printf("Error: Cannot read PPM dimensions\n");
		fclose(fp);
		return -1;
	}

	c = getc(fp);
	while (c == '#' || isspace(c)) {
		if (c == '#') {
			while (c != '\n' && c != EOF) {
				c = getc(fp);
			}
		}
		if (c != EOF) {
			c = getc(fp);
		}
	}
	ungetc(c, fp);

	if (fscanf(fp, "%d", &maxval) != 1) {
		printf("Error: Cannot read max value\n");
		fclose(fp);
		return -1;
	}

	if (maxval > 255) {
		printf("Error: PPM max value > 255\n");
		fclose(fp);
		return -1;
	}

	data = (unsigned char *)malloc(width * height * 3);
	if (!data) {
		printf("Error: Cannot allocate memory for PPM data\n");
		fclose(fp);
		return -1;
	}

	count = 0;
	for (i = 0; i < width * height; i++) {
		if (fscanf(fp, "%d %d %d", &r, &g, &b) != 3) {
			printf("Error: Cannot read PPM pixel data\n");
			free(data);
			fclose(fp);
			return -1;
		}

		data[count++] = (unsigned char)((r * 255) / maxval);
		data[count++] = (unsigned char)((g * 255) / maxval);
		data[count++] = (unsigned char)((b * 255) / maxval);
	}

	fclose(fp);

	/* put into sprites array */
	sprites[sprite_id].width = width;
	sprites[sprite_id].height = height;
	sprites[sprite_id].data = data;
	sprites[sprite_id].loaded = 1;
	numLoadedSprites++;

	return sprite_id;
}

void draw_sprite(int sprite_id, int x, int y) {
	int i, j, index;
	static int palette_initialized = 0;
	unsigned char r, g, b;
	unsigned char color;
	RGB pixel_color;
	RGB palette[256];

	if (!palette_initialized) {
		vga_to_rgb(palette);
		palette_initialized = 1;
	}

	if (sprite_id < 0 || sprite_id >= MAX_SPRITES || !sprites[sprite_id].loaded) {
		printf("Error: Invalid sprite ID\n");
		return;
	}

	/* simple loop through sprite array */
	for (j = 0; j < sprites[sprite_id].height; j++) {
		for (i = 0; i < sprites[sprite_id].width; i++) {
			index = (j * sprites[sprite_id].width + i) * 3;
			r = sprites[sprite_id].data[index];
			g = sprites[sprite_id].data[index + 1];
			b = sprites[sprite_id].data[index + 2];

			pixel_color.r = r;
			pixel_color.g = g;
			pixel_color.b = b;
			color = find_closest_color(pixel_color, palette);

			put_pixel(x + i, y + j, color);
		}
	}
}

void free_sprite(int sprite_id)
{
	if (sprite_id >= 0 && sprite_id < MAX_SPRITES && sprites[sprite_id].loaded) {
		free(sprites[sprite_id].data);
		sprites[sprite_id].loaded = 0;
		numLoadedSprites--;
	}
}

void free_all_sprites(void)
{
	int i;
	for (i = 0; i < MAX_SPRITES; i++) {
		if (sprites[i].loaded) {
			free_sprite(i);
		}
	}
}

